## How the protocol works
https://www.damnvulnerabledefi.xyz/challenges/the-rewarder/

The features as the websites shows in the bleow
``` There’s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it.

Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards!

You don’t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself.

By the way, rumours say a new pool has just launched. Isn’t it offering flash loans of DVT tokens?
```

* Each user have deposited 100(18 decimals) liquidityToken tokens in the first round.
* And all users have get their rewards currently, Now is the second round. each got 25 rewardToken, and they can still get 25 rewardToken in the following round  The reward calculation as these:

    * `rewards = amountDeposited.mulDiv(REWARDS, totalDeposits);` 
    * `rewards = userDeposited*100 ether / totalDeposits`   (100 ether keep the precision as 20 decimals)
    

## The analysis about this protocol

* There are four main smart contracts:
1. TheRewarderPool

   1. It's the main and entrance for the protocol. Users can deposit the liquidityToken in one round and get rewards in the following round. Also can withdraw their liquidityToken. 

   2.  There are two ways to get the rewards. One is if they deposit the liquidityToken and they have deposited some liquidityToken in the previous rouund, they can get the corrospending awards. Another is can directly call distributeRewards if they have deposited the liquidityToken in the previous rouund.

2. RewardToken, obviously it's the reward tokens

3. liquidityToken, ERC20 token. Users take some amounts of the token to deposit.

4. AccountingToken
    * This contract records how many rewards token should be given to the user. The contract is based on the ERC20Snapshot, For this protocol is not for voting but recording the last balance of user or totalSupply. AccountingToken is peg 1:1 RewardToken.

* FlashLoanerPool, one user can flashloan the liquidityToken by this contract.


## The problem or tricks

The problem is rooted in the AccountingToken and how it use the ERC20Snapshot.

When enter a new round, the TheRewarderPool will store the lastSnapshotId as lastSnapshotIdForRewards, and its corresponding timestampe as lastRecordedSnapshotTimestamp


For the snapshots, which store the history balance  as below
```solidity 

mapping(address => Snapshots) private _accountBalanceSnapshots; // Store each address last balance

Snapshots private _totalSupplySnapshots; 

struct Snapshots { 
        uint256[] ids;
        uint256[] values;
    }
```

The logic in simple terms is
when one sanphshotId is created, snapshots is no value no matter the totalSupply or the accountBalance. 
when transfer occures, snapshots will store the old value before the balance changed.

So, As this show: current stage the snapshotId or lastSnapshotIdForRewards = 2. and the snapshots's value as below 
* ``` ids [1], values [0] ``` each user address
* ``` ids [1], values [0] ``` total supply
  * That means mint in 1th round, store the last balance. Now query by snapshotId=2, accountingToken will return its current balance.


Now, assume can get a great number of liquidityToken in 3th round by flashloan, deposit and withdraw. What has happend?
1. depoist will trigger the below things:
    * before generating the new snapshotId=3, the snapshot has changed as below
        * ``` ids [2], values [0] ```   hacker address
        * ``` ids [1,2], values [0,400] ``` total supply
    * make new snapshotId=3
    * call distributeRewards 
        * Because now snapshotId=3, so the hacker will make the below number greater than 0. which will get more rewards if deposit more liquidityToken.
        And if the amount is very huge which will make other's rewards become very small As the Denominator's number compraing the numerator is very large.
        
        ```solidity
        uint256 totalDeposits = accountingToken.totalSupplyAt(lastSnapshotIdForRewards); 
        uint256 amountDeposited = accountingToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards);
        
        ```

**So the core problem is by using snapshot when there are no snapshots corrospending to current snapshotId,return the current balance. But as above show when using flashloan, current balance of acccountingToken has been modified.**


reference: https://www.rareskills.io/post/erc20-snapshot


## Exploit steps

* STEP 1:
    * the time passed 5 days, should be in the 3th round.
    * hacker flashloan liquidityToken and deposit all this token deposit the TheRewarderPool
* STEP 2:
    *  hacker can get the rewards based on the deposit tokens during the deposit caling.
    [why get more rewards](https://github.com/sodexx7/security_related/blob/main/damn-vulnerable-defi/contracts/the-rewarder/Exploit_README.md#L71) 
* STEP 3:
    *  hacker withdraw all the token and return all to the FlashLoanerPool
* STEP 4:
    * after flashloan,return all rewards to player.address

